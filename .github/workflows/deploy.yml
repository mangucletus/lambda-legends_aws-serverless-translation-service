# .github/workflows/deploy.yml
# GitHub Actions workflow for AWS Translate Application deployment

name: Deploy AWS Translate Application

# Trigger the workflow on push to main branch or manual dispatch
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

# Environment variables
env:
  AWS_REGION: ${{ secrets.AWS_REGION || 'us-east-1' }}
  TF_STATE_BUCKET: ${{ secrets.TF_STATE_BUCKET }}
  PROJECT_NAME: aws-translate-app
  ENVIRONMENT: dev

# Define jobs
jobs:
  # Validate and plan Terraform changes
  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    outputs:
      tfplan: ${{ steps.plan.outputs.tfplan }}
      
    steps:
    # Checkout the repository code
    - name: Checkout code
      uses: actions/checkout@v4

    # Configure AWS credentials
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    # Setup Terraform
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ~1.0
        terraform_wrapper: false

    # Validate AWS credentials
    - name: Validate AWS credentials
      run: |
        aws sts get-caller-identity
        echo "AWS credentials configured successfully"

    # Verify Terraform backend bucket exists
    - name: Verify Terraform state bucket
      run: |
        if aws s3api head-bucket --bucket "${{ env.TF_STATE_BUCKET }}" 2>/dev/null; then
          echo "Terraform state bucket exists: ${{ env.TF_STATE_BUCKET }}"
        else
          echo "Error: Terraform state bucket does not exist: ${{ env.TF_STATE_BUCKET }}"
          echo "Please create the bucket with: aws s3 mb s3://${{ env.TF_STATE_BUCKET }}"
          exit 1
        fi

    # Update Terraform backend configuration
    - name: Update backend configuration
      run: |
        sed -i 's/your-terraform-state-bucket-unique-name/${{ env.TF_STATE_BUCKET }}/g' infrastructure/backend.tf
        sed -i 's/us-east-1/${{ env.AWS_REGION }}/g' infrastructure/backend.tf

    # Initialize Terraform
    - name: Terraform Init
      run: |
        cd infrastructure
        terraform init -backend-config="bucket=${{ env.TF_STATE_BUCKET }}"

    # Validate Terraform configuration
    - name: Terraform Validate
      run: |
        cd infrastructure
        terraform validate

    # Format check
    - name: Terraform Format Check
      run: |
        cd infrastructure
        terraform fmt -check

    # Create Terraform plan
    - name: Terraform Plan
      id: plan
      run: |
        cd infrastructure
        terraform plan -out=tfplan \
          -var="aws_region=${{ env.AWS_REGION }}" \
          -var="project_name=${{ env.PROJECT_NAME }}" \
          -var="environment=${{ env.ENVIRONMENT }}" \
          -detailed-exitcode
      continue-on-error: true

    # Upload plan artifact
    - name: Upload Terraform Plan
      uses: actions/upload-artifact@v4
      with:
        name: terraform-plan
        path: infrastructure/tfplan
        retention-days: 5

    # Comment PR with plan (if this is a PR)
    - name: Comment PR with plan
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const plan = '${{ steps.plan.outputs.stdout }}';
          const truncatedPlan = plan.length > 65000 ? plan.substring(0, 65000) + '...(truncated)' : plan;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: `## Terraform Plan üìã
            
            \`\`\`terraform
            ${truncatedPlan}
            \`\`\`
            
            Plan Status: ${{ steps.plan.outcome }}
            `
          });

  # Deploy infrastructure (only on main branch)
  terraform-apply:
    name: Terraform Apply
    needs: terraform-plan
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
    # Checkout the repository code
    - name: Checkout code
      uses: actions/checkout@v4

    # Configure AWS credentials
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    # Setup Terraform
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ~1.0
        terraform_wrapper: false

    # Update Terraform backend configuration
    - name: Update backend configuration
      run: |
        sed -i 's/your-terraform-state-bucket-unique-name/${{ env.TF_STATE_BUCKET }}/g' infrastructure/backend.tf
        sed -i 's/us-east-1/${{ env.AWS_REGION }}/g' infrastructure/backend.tf

    # Initialize Terraform
    - name: Terraform Init
      run: |
        cd infrastructure
        terraform init -backend-config="bucket=${{ env.TF_STATE_BUCKET }}"

    # Apply Terraform configuration
    - name: Terraform Apply
      run: |
        cd infrastructure
        terraform apply -auto-approve \
          -var="aws_region=${{ env.AWS_REGION }}" \
          -var="project_name=${{ env.PROJECT_NAME }}" \
          -var="environment=${{ env.ENVIRONMENT }}"

    # Get Terraform outputs
    - name: Get Terraform Outputs
      id: tf-outputs
      run: |
        cd infrastructure
        echo "frontend_url=$(terraform output -raw frontend_url)" >> $GITHUB_OUTPUT
        echo "api_gateway_url=$(terraform output -raw api_gateway_url)" >> $GITHUB_OUTPUT
        echo "cognito_user_pool_id=$(terraform output -raw cognito_user_pool_id)" >> $GITHUB_OUTPUT
        echo "cognito_user_pool_client_id=$(terraform output -raw cognito_user_pool_client_id)" >> $GITHUB_OUTPUT
        echo "cognito_identity_pool_id=$(terraform output -raw cognito_identity_pool_id)" >> $GITHUB_OUTPUT
        echo "request_bucket_name=$(terraform output -raw request_bucket_name)" >> $GITHUB_OUTPUT
        echo "response_bucket_name=$(terraform output -raw response_bucket_name)" >> $GITHUB_OUTPUT
        echo "frontend_bucket_name=$(terraform output -raw frontend_bucket_name)" >> $GITHUB_OUTPUT

    # Store outputs for next job
    - name: Store Terraform Outputs
      run: |
        mkdir -p terraform-outputs
        cd infrastructure
        terraform output -json > ../terraform-outputs/outputs.json

    # Upload outputs artifact
    - name: Upload Terraform Outputs
      uses: actions/upload-artifact@v4
      with:
        name: terraform-outputs
        path: terraform-outputs/
        retention-days: 5

  # Build and deploy frontend
  deploy-frontend:
    name: Deploy Frontend
    needs: terraform-apply
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
    # Checkout the repository code
    - name: Checkout code
      uses: actions/checkout@v4

    # Setup Node.js
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    # Configure AWS credentials
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    # Download Terraform outputs
    - name: Download Terraform Outputs
      uses: actions/download-artifact@v4
      with:
        name: terraform-outputs
        path: terraform-outputs/

    # Create AWS configuration for frontend
    - name: Create AWS configuration
      run: |
        cd frontend/src
        
        # Extract values from Terraform outputs
        COGNITO_USER_POOL_ID=$(cat ../../terraform-outputs/outputs.json | jq -r '.cognito_user_pool_id.value')
        COGNITO_USER_POOL_CLIENT_ID=$(cat ../../terraform-outputs/outputs.json | jq -r '.cognito_user_pool_client_id.value')
        COGNITO_IDENTITY_POOL_ID=$(cat ../../terraform-outputs/outputs.json | jq -r '.cognito_identity_pool_id.value')
        API_GATEWAY_URL=$(cat ../../terraform-outputs/outputs.json | jq -r '.api_gateway_url.value')
        REQUEST_BUCKET=$(cat ../../terraform-outputs/outputs.json | jq -r '.request_bucket_name.value')
        RESPONSE_BUCKET=$(cat ../../terraform-outputs/outputs.json | jq -r '.response_bucket_name.value')
        
        # Create AWS config file
        cat > aws-config.js << EOF
        // aws-config.js
        // AWS configuration for the React application
        // This file is auto-generated by the CI/CD pipeline
        
        const awsConfig = {
          region: '${{ env.AWS_REGION }}',
          userPoolId: '${COGNITO_USER_POOL_ID}',
          userPoolWebClientId: '${COGNITO_USER_POOL_CLIENT_ID}',
          identityPoolId: '${COGNITO_IDENTITY_POOL_ID}',
          apiGatewayUrl: '${API_GATEWAY_URL}',
          requestBucketName: '${REQUEST_BUCKET}',
          responseBucketName: '${RESPONSE_BUCKET}'
        };
        
        // Validation function to check if configuration is properly set
        export const validateConfig = () => {
          // In deployed version, always return true since config is auto-generated
          return true;
        };
        
        // Log configuration status (deployed version)
        if (process.env.NODE_ENV === 'development') {
          console.log('üöÄ AWS Configuration: DEPLOYED VERSION - All values set automatically');
        }
        
        // Supported languages for the translation service
        export const SUPPORTED_LANGUAGES = {
          'af': 'Afrikaans',
          'sq': 'Albanian', 
          'am': 'Amharic',
          'ar': 'Arabic',
          'hy': 'Armenian',
          'az': 'Azerbaijani',
          'bn': 'Bengali',
          'bs': 'Bosnian',
          'bg': 'Bulgarian',
          'ca': 'Catalan',
          'zh': 'Chinese (Simplified)',
          'zh-TW': 'Chinese (Traditional)',
          'hr': 'Croatian',
          'cs': 'Czech',
          'da': 'Danish',
          'fa-AF': 'Dari',
          'nl': 'Dutch',
          'en': 'English',
          'et': 'Estonian',
          'fa': 'Farsi (Persian)',
          'tl': 'Filipino, Tagalog',
          'fi': 'Finnish',
          'fr': 'French',
          'fr-CA': 'French (Canada)',
          'ka': 'Georgian',
          'de': 'German',
          'el': 'Greek',
          'gu': 'Gujarati',
          'ht': 'Haitian Creole',
          'ha': 'Hausa',
          'he': 'Hebrew',
          'hi': 'Hindi',
          'hu': 'Hungarian',
          'is': 'Icelandic',
          'id': 'Indonesian',
          'ga': 'Irish',
          'it': 'Italian',
          'ja': 'Japanese',
          'kn': 'Kannada',
          'kk': 'Kazakh',
          'ko': 'Korean',
          'lv': 'Latvian',
          'lt': 'Lithuanian',
          'mk': 'Macedonian',
          'ms': 'Malay',
          'ml': 'Malayalam',
          'mt': 'Maltese',
          'mr': 'Marathi',
          'mn': 'Mongolian',
          'no': 'Norwegian (Bokm√•l)',
          'ps': 'Pashto',
          'pl': 'Polish',
          'pt': 'Portuguese (Brazil)',
          'pt-PT': 'Portuguese (Portugal)',
          'pa': 'Punjabi',
          'ro': 'Romanian',
          'ru': 'Russian',
          'sr': 'Serbian',
          'si': 'Sinhala',
          'sk': 'Slovak',
          'sl': 'Slovenian',
          'so': 'Somali',
          'es': 'Spanish',
          'es-MX': 'Spanish (Mexico)',
          'sw': 'Swahili',
          'sv': 'Swedish',
          'ta': 'Tamil',
          'te': 'Telugu',
          'th': 'Thai',
          'tr': 'Turkish',
          'uk': 'Ukrainian',
          'ur': 'Urdu',
          'uz': 'Uzbek',
          'vi': 'Vietnamese',
          'cy': 'Welsh'
        };
        
        // Common language pairs for quick selection
        export const COMMON_LANGUAGE_PAIRS = [
          { source: 'en', target: 'es', label: 'English ‚Üí Spanish' },
          { source: 'en', target: 'fr', label: 'English ‚Üí French' },
          { source: 'en', target: 'de', label: 'English ‚Üí German' },
          { source: 'en', target: 'zh', label: 'English ‚Üí Chinese' },
          { source: 'en', target: 'ja', label: 'English ‚Üí Japanese' },
          { source: 'en', target: 'ko', label: 'English ‚Üí Korean' },
          { source: 'es', target: 'en', label: 'Spanish ‚Üí English' },
          { source: 'fr', target: 'en', label: 'French ‚Üí English' },
          { source: 'de', target: 'en', label: 'German ‚Üí English' },
          { source: 'zh', target: 'en', label: 'Chinese ‚Üí English' }
        ];
        
        export default awsConfig;
        EOF
        
        echo "AWS configuration created successfully"

    # Ensure public directory exists with required files
    - name: Ensure public directory structure
      run: |
        cd frontend
        
        # Create public directory if it doesn't exist
        mkdir -p public
        
        # Create manifest.json if it doesn't exist
        if [ ! -f public/manifest.json ]; then
          cat > public/manifest.json << EOF
        {
          "short_name": "AWS Translate",
          "name": "AWS Translate Application",
          "start_url": ".",
          "display": "standalone",
          "theme_color": "#0073bb",
          "background_color": "#ffffff"
        }
        EOF
        fi
        
        echo "Public directory structure verified"

    # Install frontend dependencies
    - name: Install dependencies
      run: |
        cd frontend
        rm -f package-lock.json
        npm install

    # Build the React application
    - name: Build React app
      run: |
        cd frontend
        npm run build
      env:
        CI: false

    # Get frontend bucket name
    - name: Get frontend bucket name
      id: bucket
      run: |
        FRONTEND_BUCKET=$(cat terraform-outputs/outputs.json | jq -r '.frontend_bucket_name.value')
        echo "frontend_bucket=${FRONTEND_BUCKET}" >> $GITHUB_OUTPUT

    # Deploy to S3
    - name: Deploy to S3
      run: |
        cd frontend
        aws s3 sync build/ s3://${{ steps.bucket.outputs.frontend_bucket }} --delete
        echo "Frontend deployed to S3 bucket: ${{ steps.bucket.outputs.frontend_bucket }}"

    # Invalidate CloudFront cache
    - name: Invalidate CloudFront
      run: |
        DISTRIBUTION_ID=$(cat terraform-outputs/outputs.json | jq -r '.cloudfront_distribution_id.value')
        aws cloudfront create-invalidation --distribution-id ${DISTRIBUTION_ID} --paths "/*"
        echo "CloudFront cache invalidated for distribution: ${DISTRIBUTION_ID}"

    # Get final URLs
    - name: Get application URLs
      id: urls
      run: |
        FRONTEND_URL=$(cat terraform-outputs/outputs.json | jq -r '.frontend_url.value')
        API_URL=$(cat terraform-outputs/outputs.json | jq -r '.api_gateway_url.value')
        echo "frontend_url=${FRONTEND_URL}" >> $GITHUB_OUTPUT
        echo "api_url=${API_URL}" >> $GITHUB_OUTPUT

    # Post deployment summary
    - name: Deployment Summary
      run: |
        echo "üöÄ Deployment completed successfully!"
        echo ""
        echo "üì± Frontend URL: ${{ steps.urls.outputs.frontend_url }}"
        echo "üîó API Gateway URL: ${{ steps.urls.outputs.api_url }}"
        echo ""
        echo "üéâ Your AWS Translate application is now live!"

  # Security and compliance checks
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
    # Checkout the repository code
    - name: Checkout code
      uses: actions/checkout@v4

    # Run Terraform security scan with tfsec
    - name: Run tfsec
      uses: aquasecurity/tfsec-action@v1.0.3
      with:
        working_directory: infrastructure/

    # Scan for secrets
    - name: Run TruffleHog OSS
      uses: trufflesecurity/trufflehog@main
      with:
        path: ./
        base: main
        head: HEAD

  # Cleanup job for failed deployments
  cleanup:
    name: Cleanup on Failure
    needs: [terraform-plan, terraform-apply, deploy-frontend]
    runs-on: ubuntu-latest
    if: failure() && github.ref == 'refs/heads/main'
    
    steps:
    # Checkout the repository code
    - name: Checkout code
      uses: actions/checkout@v4

    # Configure AWS credentials
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    # Notification (optional - requires webhook setup)
    - name: Notify on failure
      run: |
        echo "‚ö†Ô∏è Deployment failed! Please check the logs and fix any issues."
        echo "Failed jobs may have left partial resources. Consider running terraform destroy if needed."